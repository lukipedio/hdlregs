
-- VHDL component for module 'example'
-- automatically generated by HDLRegs version 0.5 on 2013-12-17 14:09

library ieee;

use ieee.std_logic_1164.all;
use work.example_regs_pkg.all;

entity example_regs is
    port(
        clk     : in  std_logic;                     -- system clock
        rst     : in  std_logic;                     -- synchronous, high-active
        addr    : in  std_logic_vector(31 downto 0); -- read/write address
        cs      : in  std_logic;                     -- chip select
        rnw     : in  std_logic;                     -- read (1) or write (0)
        datain  : in  std_logic_vector(31 downto 0); -- write data
        dataout : out std_logic_vector(31 downto 0); -- read data
        --
        regs2user : out t_regs2user; -- register file -> user logic
        user2regs : in t_user2regs -- user logic -> register file
    );
end entity example_regs;

architecture RTL of example_regs is

    signal s_version_r : std_logic_vector(31 downto 0) := x"00000001";
    signal s_control_r : std_logic_vector(31 downto 0) := x"80000000";
    signal s_control_strobe_r : std_logic := '0';

begin
    register_write : process(clk) is
    begin
        if rising_edge(clk) then
            if rst = '1' then
                s_version_r <= x"00000001";
                s_control_r <= x"80000000";
            else
                -- defaults:
                s_control_strobe_r <= '0';
                -- self-clearing fields:
                s_control_r(OFFSET_CONTROL_START + WIDTH_CONTROL_START - 1 downto OFFSET_CONTROL_START) <= (others => '0');
                -- bus write:
                if cs = '1' and rnw = '0' then
                    if addr = ADDR_CONTROL then
                        s_control_r(OFFSET_CONTROL_RESET + WIDTH_CONTROL_RESET - 1 downto OFFSET_CONTROL_RESET) <= datain(OFFSET_CONTROL_RESET + WIDTH_CONTROL_RESET - 1 downto OFFSET_CONTROL_RESET);
                        s_control_strobe_r <= '1';
                        s_control_r(OFFSET_CONTROL_START + WIDTH_CONTROL_START - 1 downto OFFSET_CONTROL_START) <= datain(OFFSET_CONTROL_START + WIDTH_CONTROL_START - 1 downto OFFSET_CONTROL_START);
                        s_control_strobe_r <= '1';
                    end if;
                end if;
                -- user-logic write:
                if user2regs.version.high.strobe = '1' then
                    s_version_r(OFFSET_VERSION_HIGH + WIDTH_VERSION_HIGH - 1 downto OFFSET_VERSION_HIGH) <= user2regs.version.high.value;
                end if;
                if user2regs.version.low.strobe = '1' then
                    s_version_r(OFFSET_VERSION_LOW + WIDTH_VERSION_LOW - 1 downto OFFSET_VERSION_LOW) <= user2regs.version.low.value;
                end if;
                if user2regs.control.done.strobe = '1' then
                    s_control_r(OFFSET_CONTROL_DONE + WIDTH_CONTROL_DONE - 1 downto OFFSET_CONTROL_DONE) <= user2regs.control.done.value;
                end if;
            end if;
        end if;
    end process register_write;

    bus_read : process (cs,rnw,addr,s_version_r,s_control_r) is
    begin
        dataout <= (others => 'X'); -- default
        if cs = '1' and rnw = '1' then
            if addr = ADDR_VERSION then
                dataout(OFFSET_VERSION_HIGH + WIDTH_VERSION_HIGH - 1 downto OFFSET_VERSION_HIGH) <= s_version_r(OFFSET_VERSION_HIGH + WIDTH_VERSION_HIGH - 1 downto OFFSET_VERSION_HIGH);
                dataout(OFFSET_VERSION_LOW + WIDTH_VERSION_LOW - 1 downto OFFSET_VERSION_LOW) <= s_version_r(OFFSET_VERSION_LOW + WIDTH_VERSION_LOW - 1 downto OFFSET_VERSION_LOW);
            end if;
            if addr = ADDR_CONTROL then
                dataout(OFFSET_CONTROL_RESET + WIDTH_CONTROL_RESET - 1 downto OFFSET_CONTROL_RESET) <= s_control_r(OFFSET_CONTROL_RESET + WIDTH_CONTROL_RESET - 1 downto OFFSET_CONTROL_RESET);
                dataout(OFFSET_CONTROL_DONE + WIDTH_CONTROL_DONE - 1 downto OFFSET_CONTROL_DONE) <= s_control_r(OFFSET_CONTROL_DONE + WIDTH_CONTROL_DONE - 1 downto OFFSET_CONTROL_DONE);
            end if;
        end if;
    end process bus_read;


    regs2user.control.reset.value <= s_control_r(OFFSET_CONTROL_RESET + WIDTH_CONTROL_RESET - 1 downto OFFSET_CONTROL_RESET);
    regs2user.control.reset.strobe <= s_control_strobe_r;
    regs2user.control.start.value <= s_control_r(OFFSET_CONTROL_START + WIDTH_CONTROL_START - 1 downto OFFSET_CONTROL_START);
    regs2user.control.start.strobe <= s_control_strobe_r;

end architecture RTL;

